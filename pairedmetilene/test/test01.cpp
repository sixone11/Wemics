#include "../src/mm2.h"
#include "../src/mm2.cpp"

#include<iostream>
#include<vector>
#define NDEBUG__

double f_unit01(double theta, std::vector<double> x){
    return (x[0]-theta)*x[1];
}

int main(int argc, char * argv[]){
    int n = 100;
    double y[100] = {5.70841597123488,1.16105036522001,3.03298310654448,2.95492994291845,0.69515801312371,1.4109290810625,1.34599909143968,0.972772846504799,1.77128505955512,3.01426875752551,1.15130743106093,0.337317558048664,0.526686689263656,0.543283570978707,0.260266831392367,3.80528487392854,1.88006627122576,3.65942691763834,1.79561588480851,1.02796459358054,4.88890746904552,7.43974015325405,9.0800742560472,2.67498148382855,2.92101877333,1.58200858826724,1.15036945731479,2.54316657100405,1.43216808643412,4.17252963140308,5.72790677981478,1.08973969589932,1.00475992224832,2.01397870704599,1.85018625741336,2.74309778838494,7.04471064081053,0.161740801370753,0.662253671858533,5.22904187788313,0.887231367025634,0.981804205554699,1.369972416685,1.94596063733735,2.03576011164399,0.571906350337985,1.04820521389823,3.19515995841906,2.23790863069285,5.4512258873028,2.57004686163195,0.871027846274257,1.11764432565387,5.68597492403261,1.54729545854393,3.02554417963128,3.84499114866344,0.987396734362292,1.05598092448005,2.49580999176308,3.24732496190826,0.504906004936819,3.16926274517804,0.999955132714451,0.37465158409623,3.8677746699753,0.144876181940457,0.164832596837646,5.37762211702339,1.81404287681376,1.62773743174368,1.73950600981053,2.23945204290286,1.46362314038765,1.08221688707792,0.931429730599037,5.10286551534995,2.40255151891813,2.64554109894279,0.879677937554099,1.66222834122358,1.25343907935657,1.18946563483277,2.39442916927845,0.770356406177033,0.0156517962206198,4.36575479294092,7.19688338978507,0.635758885283141,2.66062869882376,0.458717089885339,3.51068070098467,2.14269039387996,0.513627064107291,3.46945174935618,3.57409342246924,3.65441286507865,7.01791676524882,2.80061557010054,0.575424783570439};
    std::vector<double> yy(y, y+n);
 #ifdef DEBUG__
    double mean = 0.;
    double sd = 0.;
    double re[3] = {0,0,0};
    for(size_t i = 0; i<n; i++) mean += y[i];
    mean = mean/n;
    for(size_t i = 0; i<n; i++) sd += (y[i]-mean)*(y[i]-mean);
    sd = sqrt(sd/(n+1.));
    double param_init[2] = {mean, sd};
    solver_sam_function(y, n, param_init, re);
    std::cout << "MLE:("<< re[0]<<" ,"<<re[1]<<")"<<std::endl;
#endif
    std::cout << "-2llr = "<<LRFstat(y, (size_t) n) << std::endl;
    std::vector<double> test_unit01({0.1, 20});

    // use this version for your convinience
    std::vector<double> re_vec=LRFstat(yy);
    std::cout <<"MLE: ("<<re_vec[0]<<","<<re_vec[1]<< ")\n-2llr = "<<re_vec[2] << std::endl;
    // Test uniroot:
    std::cout <<"Uniroot: "<<f_uniroot(f_unit01, -2, 2, test_unit01, true);
    return 0;
}
